{"title":"Cadenas de Texto","markdown":{"yaml":{"title":"Cadenas de Texto","author":"Alex Dannis Lipa Quispe"},"headingText":"char\\[n\\]:","containsRefs":false,"markdown":"\n\n\nUna manera de guardar cadenas de texto es usar en vector de tipo char, es una manera un poco eficiente, pero esta bien si tu programa no requiere de mucho texto en las entradas, se guarda de la siguiente manera:\n\n``` cpp\n#include <iostream>\nusing namespace std;\nint main(){\n    char nombre[100]; //cuardamos memoría para 100 carácteres\n    cout << \"Digite su nombre: \";\n    cin.getline(nombre,100,'\\n');\n    cout << \"Su nombre guardado es: \"<<nombre<<endl;\n    return 0;\n}\n```\n\nEn este caso, para poder guardar las cadenas de texto utilizamos **`cin.getline()`**, que en este caso usa 3 parámetros:  \nen el primero nos preguntamos ¿Dónde lo quieres guardar? (en este caso es en **nombre**),  \nen el segundo, ¿cuántos espacios tiene? (ahí ponemos la cantidad que reservamos en el inicio),  \ny por último, ¿cuándo queremos que termine? En ese lugar pondremos un salto de línea que es **\\texttt{`\\textbackslash n`}**,  \nes decir, que al apretar la tecla **Enter** se guardará la cantidad de caracteres antes de dicha acción.  \nEjemplo de compilación:\n\n```{=latex}\n\\begin{tcolorbox}[custombox]\n\\begin{verbatim}\nDigite su nombre: Maria Gonzales Perez\nSu nombre guardado es: Maria Gonzales Perez\n\\end{verbatim}\n\\end{tcolorbox}\n```\n\nAlgunas carácteristicas especiales que puedes usar son las siguientes para que algunas de estas funciones correctamente es necesario usar **#include\\<cstdlib\\>** (donde var es una variables):\n\nFunciones clásicas de manejo de `char[]` (cstring)\n\n> Estas funciones trabajan con arreglos de caracteres (`char[]`), no con objetos `string`. Se requiere incluir la cabecera `#include <cstring>` y en algunos casos `#include <cstdlib>`.\n\n| **Método** | **¿Para qué sirve?** | **Ejemplo** | **Resultado** |\n|----------------|-------------------------|-----------------|----------------|\n| `strlen(var)` | Obtener la longitud de una cadena | `int num = strlen(\"alex\");` | `num = 4` |\n| `strcpy(dest, src)` | Copiar el contenido de una cadena en otra | `strcpy(var1, \"Alex\");` | `var1 = \"Alex\"` |\n| `strcmp(a, b)` | Comparar dos cadenas | `strcmp(\"hola\", \"hola\") == 0` | `true` si son iguales |\n| `strcat(a, b)` | Concatenar dos cadenas | `strcat(var1, \"Alex\");` | Si `var1 = \"Hola \"`, entonces `\"Hola Alex\"` |\n| `strrev(var)` | Invertir una cadena | `char r[10] = strrev(var1);` | Si `var1 = \"dia\"`, entonces `\"aid\"` |\n| `strupr(var)` | Convertir a mayúsculas | `strupr(var1);` | Si `var1 = \"paz\"`, será `\"PAZ\"` |\n| `strlwr(var)` | Convertir a minúsculas | `strlwr(var1);` | Si `var1 = \"PAZ\"`, será `\"paz\"` |\n| `strncmp(a, b, n)` | Comparar los primeros `n` caracteres de dos cadenas | `strncmp(\"alex\", \"a\", 1) == 0` | `true` porque `'a' == 'a'` |\n| `atoi(var)` | Convertir texto a entero | `int num = atoi(\"2\");` | `num = 2` |\n| `atof(var)` | Convertir texto a número con decimales | `float num = atof(\"2.3\");` | `num = 2.3` |\n\n> ⚠️ Nota: `strrev`, `strupr` y `strlwr` no son funciones estándar en C++, pero funcionan en algunos compiladores como **Dev-C++**.\n\nHagamos un ejercico simple que será verificar si una palabra tiene la 'a' minuscula en su nombre:\n\n``` cpp\n#include <iostream>\n#include <cstring> // lo utilizamos para usar strlen()\nusing namespace std;\nint main(){\n    char nombre[20];\n    bool bandera = false;\n    int cantidad = 0;\n    cout << \"Digite su nombre: \";\n    cin.getline(nombre, 20, '\\n');\n    cantidad = strlen(nombre);\n    for(int i=0; i<cantidad; i++){\n        if(nombre[i] == 'a'){\n            bandera = true;\n            break;\n        }\n    }\n    if(bandera){\n        cout << \"Su nombre contiene almenos una a.\"<<endl;\n    }else{\n        cout << \"Su nombre no contiene la vocal a.\"<<endl;\n    }\n    return 0;\n}\n```\n\nEnte programa verifica si almenos tu nombre contiene una **a** usamos 3 variables de diferentes tipos que son **char\\[20\\]** para almacenar un nombre de máximo 20 carácteres, **bool** para verificar si hay almenos una **a** en el nombre y un **int** para saber exáctamente cuantos carácteres tiene el nombre introducido. La compilación del programa será de esta manera:\n\n```{=latex}\n\\begin{tcolorbox}[custombox]\n\\begin{verbatim}\nDigite su nombre: alex\nSu nombre contiene almenos una a.\n\\end{verbatim}\n\\end{tcolorbox}\n```\n\nSi deseas ver más ejercicios de este tipo te invito a ver este video -\\>\n\n## string\n\nOtra manera de guardar cadenas de texto es usar los string que una manera más fácil de alamacenar las palabras y se entien de mejor manera, a qui te muestro un ejemplo:\n\n``` cpp\n#include <iostream>\n#include <string>  //Agregamos esta librería para poder usar las strings\nusing namespace std;\nint main(){\n    string nombre;\n    cout << \"Digite su nombre: \";\n    getline(cin, nombre); // de esta manera es como se guarda los strings\n    cout << \"Su nombre guardado es: \"<<nombre<<endl;\n    return 0;\n}\n```\n\nPara guardar los string se usa la palabra reservada **getline()** que en este caso usamos dos parámetros, para saber que poner en el primer parámetro nos preguntamos ¿Qué queremos hacer? En este caso queremos guardar y por ello ponemos **cin** en el segundo parámetro va ¿Dónde lo quieres guardar? por esa razón va el nombre de la variable de tipo string. Algunas carácteristicas básicas de los string son estos:\n\nMétodos comunes de `string` en C++\n\n| MÉTODO | ¿Para qué sirve? | Ejemplo | Resultado |\n|---------------|---------------------------|---------------|---------------|\n| `.empty()` | Verifica si la cadena está vacía | `string s = \"\"; s.empty();` | `true` |\n| `.length()` | Devuelve el número de caracteres de la cadena | `string s = \"Hola\"; s.length();` | `4` |\n| `.size()` | Igual que `.length()` | `s.size();` | `4` |\n| `.substr(pos, n)` | Devuelve una subcadena desde `pos` con `n` caracteres | `s.substr(1, 2);` | `\"ol\"` |\n| `.find()` | Devuelve la posición de una subcadena o carácter | `s.find(\"la\");` | `2` |\n| `.append(str)` | Añade `str` al final de la cadena | `s.append(\" mundo\");` | `\"Hola mundo\"` |\n| `.insert(pos, s)` | Inserta una subcadena `s` en la posición `pos` | `s.insert(2, \"xx\");` | `\"Hoxxla\"` |\n| `.erase(pos, n)` | Elimina `n` caracteres desde la posición `pos` | `s.erase(1, 2);` | `\"Ha\"` (de \"Hola\") |\n| `.replace(pos,n,s)` | Reemplaza `n` caracteres desde `pos` por `s` | `s.replace(0, 4, \"Hi\");` | `\"Hi\"` |\n| `toupper(c)` | Convierte un carácter a mayúscula | `toupper('a');` | `'A'` |\n| `tolower(c)` | Convierte un carácter a minúscula | `tolower('A');` | `'a'` |\n| `isalnum(c)` | Verifica si un carácter es alfanumérico | `isalnum('3');` | `true` |\n| `isalpha(c)` | Verifica si un carácter es una letra | `isalpha('A');` | `true` |\n| `isdigit(c)` | Verifica si un carácter es un dígito | `isdigit('8');` | `true` |\n\n> **Nota:** funciones como `toupper()`, `isdigit()`, etc., requieren incluir la librería `#include <cctype>`.\n\nComo modo de práctica hagámos un programa que verifique si la primera y última palabar inician con un caracter, si es haci que imprima \"hola muno\" y si no mostrar \"buenas noches\".\n```cpp\n#include <iostream>\n#include <cctype> // para usar isalpha()\n#include <cstring>\nusing namespace std;\nint main(){\n    string palabra;\n    int tam = 0;\n    cout << \"Digite una palabra: \";\n    getline(cin, palabra);\n    tam = palabra.length();\n    if(isalpha(palabra[0]) && isalpha(palabra[tam-1])){\n        cout << \"hola mundo.\"<<endl;\n    }else{\n        cout << \"buenas noches.\"<<endl;\n    }\n    return 0;\n}\n```\nEn este lo que hicimos es verificar si una palabra empieza y termina con un caracter, como en los vectores las string tienen índices e inician de igual manera pos el 0. Por ese motivo en la estructura de control **if** pusimos `palabra[0]` y `palabra[tam-1]` si pusiera la palabra **casa** lo que la condicional verificaría sería esto: `c y a` ¿Son string? si, y por ello el resultado sería **true** e imprimiría \"hola mundo\" y en caso contrario \"buenas noches\", a qui te muestro un ejemplo de compilación:\n```{=latex}\n\\begin{tcolorbox}[custombox]\n\\begin{verbatim}\nDigite una palabra: casa\nhola mundo.\n---> caso contrario <---\nDigite una palabra: casa7\nbuenas noches.\n\\end{verbatim}\n\\end{tcolorbox}\n```\nSi te quedaste con intriga y deseas saber más te invito a que le des un vistaso a este video ->","srcMarkdownNoYaml":"\n\n## char\\[n\\]:\n\nUna manera de guardar cadenas de texto es usar en vector de tipo char, es una manera un poco eficiente, pero esta bien si tu programa no requiere de mucho texto en las entradas, se guarda de la siguiente manera:\n\n``` cpp\n#include <iostream>\nusing namespace std;\nint main(){\n    char nombre[100]; //cuardamos memoría para 100 carácteres\n    cout << \"Digite su nombre: \";\n    cin.getline(nombre,100,'\\n');\n    cout << \"Su nombre guardado es: \"<<nombre<<endl;\n    return 0;\n}\n```\n\nEn este caso, para poder guardar las cadenas de texto utilizamos **`cin.getline()`**, que en este caso usa 3 parámetros:  \nen el primero nos preguntamos ¿Dónde lo quieres guardar? (en este caso es en **nombre**),  \nen el segundo, ¿cuántos espacios tiene? (ahí ponemos la cantidad que reservamos en el inicio),  \ny por último, ¿cuándo queremos que termine? En ese lugar pondremos un salto de línea que es **\\texttt{`\\textbackslash n`}**,  \nes decir, que al apretar la tecla **Enter** se guardará la cantidad de caracteres antes de dicha acción.  \nEjemplo de compilación:\n\n```{=latex}\n\\begin{tcolorbox}[custombox]\n\\begin{verbatim}\nDigite su nombre: Maria Gonzales Perez\nSu nombre guardado es: Maria Gonzales Perez\n\\end{verbatim}\n\\end{tcolorbox}\n```\n\nAlgunas carácteristicas especiales que puedes usar son las siguientes para que algunas de estas funciones correctamente es necesario usar **#include\\<cstdlib\\>** (donde var es una variables):\n\nFunciones clásicas de manejo de `char[]` (cstring)\n\n> Estas funciones trabajan con arreglos de caracteres (`char[]`), no con objetos `string`. Se requiere incluir la cabecera `#include <cstring>` y en algunos casos `#include <cstdlib>`.\n\n| **Método** | **¿Para qué sirve?** | **Ejemplo** | **Resultado** |\n|----------------|-------------------------|-----------------|----------------|\n| `strlen(var)` | Obtener la longitud de una cadena | `int num = strlen(\"alex\");` | `num = 4` |\n| `strcpy(dest, src)` | Copiar el contenido de una cadena en otra | `strcpy(var1, \"Alex\");` | `var1 = \"Alex\"` |\n| `strcmp(a, b)` | Comparar dos cadenas | `strcmp(\"hola\", \"hola\") == 0` | `true` si son iguales |\n| `strcat(a, b)` | Concatenar dos cadenas | `strcat(var1, \"Alex\");` | Si `var1 = \"Hola \"`, entonces `\"Hola Alex\"` |\n| `strrev(var)` | Invertir una cadena | `char r[10] = strrev(var1);` | Si `var1 = \"dia\"`, entonces `\"aid\"` |\n| `strupr(var)` | Convertir a mayúsculas | `strupr(var1);` | Si `var1 = \"paz\"`, será `\"PAZ\"` |\n| `strlwr(var)` | Convertir a minúsculas | `strlwr(var1);` | Si `var1 = \"PAZ\"`, será `\"paz\"` |\n| `strncmp(a, b, n)` | Comparar los primeros `n` caracteres de dos cadenas | `strncmp(\"alex\", \"a\", 1) == 0` | `true` porque `'a' == 'a'` |\n| `atoi(var)` | Convertir texto a entero | `int num = atoi(\"2\");` | `num = 2` |\n| `atof(var)` | Convertir texto a número con decimales | `float num = atof(\"2.3\");` | `num = 2.3` |\n\n> ⚠️ Nota: `strrev`, `strupr` y `strlwr` no son funciones estándar en C++, pero funcionan en algunos compiladores como **Dev-C++**.\n\nHagamos un ejercico simple que será verificar si una palabra tiene la 'a' minuscula en su nombre:\n\n``` cpp\n#include <iostream>\n#include <cstring> // lo utilizamos para usar strlen()\nusing namespace std;\nint main(){\n    char nombre[20];\n    bool bandera = false;\n    int cantidad = 0;\n    cout << \"Digite su nombre: \";\n    cin.getline(nombre, 20, '\\n');\n    cantidad = strlen(nombre);\n    for(int i=0; i<cantidad; i++){\n        if(nombre[i] == 'a'){\n            bandera = true;\n            break;\n        }\n    }\n    if(bandera){\n        cout << \"Su nombre contiene almenos una a.\"<<endl;\n    }else{\n        cout << \"Su nombre no contiene la vocal a.\"<<endl;\n    }\n    return 0;\n}\n```\n\nEnte programa verifica si almenos tu nombre contiene una **a** usamos 3 variables de diferentes tipos que son **char\\[20\\]** para almacenar un nombre de máximo 20 carácteres, **bool** para verificar si hay almenos una **a** en el nombre y un **int** para saber exáctamente cuantos carácteres tiene el nombre introducido. La compilación del programa será de esta manera:\n\n```{=latex}\n\\begin{tcolorbox}[custombox]\n\\begin{verbatim}\nDigite su nombre: alex\nSu nombre contiene almenos una a.\n\\end{verbatim}\n\\end{tcolorbox}\n```\n\nSi deseas ver más ejercicios de este tipo te invito a ver este video -\\>\n\n## string\n\nOtra manera de guardar cadenas de texto es usar los string que una manera más fácil de alamacenar las palabras y se entien de mejor manera, a qui te muestro un ejemplo:\n\n``` cpp\n#include <iostream>\n#include <string>  //Agregamos esta librería para poder usar las strings\nusing namespace std;\nint main(){\n    string nombre;\n    cout << \"Digite su nombre: \";\n    getline(cin, nombre); // de esta manera es como se guarda los strings\n    cout << \"Su nombre guardado es: \"<<nombre<<endl;\n    return 0;\n}\n```\n\nPara guardar los string se usa la palabra reservada **getline()** que en este caso usamos dos parámetros, para saber que poner en el primer parámetro nos preguntamos ¿Qué queremos hacer? En este caso queremos guardar y por ello ponemos **cin** en el segundo parámetro va ¿Dónde lo quieres guardar? por esa razón va el nombre de la variable de tipo string. Algunas carácteristicas básicas de los string son estos:\n\nMétodos comunes de `string` en C++\n\n| MÉTODO | ¿Para qué sirve? | Ejemplo | Resultado |\n|---------------|---------------------------|---------------|---------------|\n| `.empty()` | Verifica si la cadena está vacía | `string s = \"\"; s.empty();` | `true` |\n| `.length()` | Devuelve el número de caracteres de la cadena | `string s = \"Hola\"; s.length();` | `4` |\n| `.size()` | Igual que `.length()` | `s.size();` | `4` |\n| `.substr(pos, n)` | Devuelve una subcadena desde `pos` con `n` caracteres | `s.substr(1, 2);` | `\"ol\"` |\n| `.find()` | Devuelve la posición de una subcadena o carácter | `s.find(\"la\");` | `2` |\n| `.append(str)` | Añade `str` al final de la cadena | `s.append(\" mundo\");` | `\"Hola mundo\"` |\n| `.insert(pos, s)` | Inserta una subcadena `s` en la posición `pos` | `s.insert(2, \"xx\");` | `\"Hoxxla\"` |\n| `.erase(pos, n)` | Elimina `n` caracteres desde la posición `pos` | `s.erase(1, 2);` | `\"Ha\"` (de \"Hola\") |\n| `.replace(pos,n,s)` | Reemplaza `n` caracteres desde `pos` por `s` | `s.replace(0, 4, \"Hi\");` | `\"Hi\"` |\n| `toupper(c)` | Convierte un carácter a mayúscula | `toupper('a');` | `'A'` |\n| `tolower(c)` | Convierte un carácter a minúscula | `tolower('A');` | `'a'` |\n| `isalnum(c)` | Verifica si un carácter es alfanumérico | `isalnum('3');` | `true` |\n| `isalpha(c)` | Verifica si un carácter es una letra | `isalpha('A');` | `true` |\n| `isdigit(c)` | Verifica si un carácter es un dígito | `isdigit('8');` | `true` |\n\n> **Nota:** funciones como `toupper()`, `isdigit()`, etc., requieren incluir la librería `#include <cctype>`.\n\nComo modo de práctica hagámos un programa que verifique si la primera y última palabar inician con un caracter, si es haci que imprima \"hola muno\" y si no mostrar \"buenas noches\".\n```cpp\n#include <iostream>\n#include <cctype> // para usar isalpha()\n#include <cstring>\nusing namespace std;\nint main(){\n    string palabra;\n    int tam = 0;\n    cout << \"Digite una palabra: \";\n    getline(cin, palabra);\n    tam = palabra.length();\n    if(isalpha(palabra[0]) && isalpha(palabra[tam-1])){\n        cout << \"hola mundo.\"<<endl;\n    }else{\n        cout << \"buenas noches.\"<<endl;\n    }\n    return 0;\n}\n```\nEn este lo que hicimos es verificar si una palabra empieza y termina con un caracter, como en los vectores las string tienen índices e inician de igual manera pos el 0. Por ese motivo en la estructura de control **if** pusimos `palabra[0]` y `palabra[tam-1]` si pusiera la palabra **casa** lo que la condicional verificaría sería esto: `c y a` ¿Son string? si, y por ello el resultado sería **true** e imprimiría \"hola mundo\" y en caso contrario \"buenas noches\", a qui te muestro un ejemplo de compilación:\n```{=latex}\n\\begin{tcolorbox}[custombox]\n\\begin{verbatim}\nDigite una palabra: casa\nhola mundo.\n---> caso contrario <---\nDigite una palabra: casa7\nbuenas noches.\n\\end{verbatim}\n\\end{tcolorbox}\n```\nSi te quedaste con intriga y deseas saber más te invito a que le des un vistaso a este video ->"},"formats":{"pdf":{"identifier":{"display-name":"PDF","target-format":"pdf","base-format":"pdf"},"execute":{"fig-width":5.5,"fig-height":3.5,"fig-format":"pdf","fig-dpi":300,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"pdf","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"pdf-engine":"xelatex","standalone":true,"variables":{"graphics":true,"tables":true},"default-image-extension":"pdf","to":"pdf","include-in-header":["preambulo.tex"],"output-file":"capitulo7.pdf"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"block-headings":true,"papersize":"a4","fontsize":"11pt","linestretch":1.3,"margin-left":"2cm","margin-right":"2cm","margin-top":"2cm","margin-bottom":"2cm","code-block-bg":true,"code-block-border-left":"#3C3C3C","code-block-font-size":"90%","title":"Cadenas de Texto","author":"Alex Dannis Lipa Quispe"},"extensions":{"book":{"selfContainedOutput":true}}}},"projectFormats":["pdf"]}